import OpenAI from 'openai';
import { ParaphraseSuggestion } from '@shared/schema';

// AI Provider interface for standardized responses
interface AIProvider {
  name: string;
  analyzeForPlagiarism(text: string): Promise<{
    aiGenerated: boolean;
    confidence: number;
    reasoning: string;
  }>;
  generateParaphrase(text: string): Promise<ParaphraseSuggestion[]>;
  available(): Promise<boolean>;
}

// OpenAI Provider
class OpenAIProvider implements AIProvider {
  name = 'OpenAI';
  private client: OpenAI;

  constructor() {
    this.client = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY,
    });
  }

  async available(): Promise<boolean> {
    try {
      await this.client.models.list();
      return true;
    } catch {
      return false;
    }
  }

  async analyzeForPlagiarism(text: string): Promise<{
    aiGenerated: boolean;
    confidence: number;
    reasoning: string;
  }> {
    const response = await this.client.chat.completions.create({
      model: 'gpt-4o',
      messages: [
        {
          role: 'system',
          content: `You are an AI detection expert. Analyze the following text and determine if it was generated by AI. 
          Consider factors like: repetitive patterns, unnatural flow, generic language, lack of personal voice, 
          perfect grammar without personality, formulaic structure. 
          Return JSON with: aiGenerated (boolean), confidence (0-1), reasoning (string).`
        },
        {
          role: 'user',
          content: text
        }
      ],
      response_format: { type: 'json_object' }
    });

    const result = JSON.parse(response.choices[0].message.content || '{}');
    return {
      aiGenerated: result.aiGenerated || false,
      confidence: Math.max(0, Math.min(1, result.confidence || 0)),
      reasoning: result.reasoning || 'Unable to analyze text'
    };
  }

  async generateParaphrase(text: string): Promise<ParaphraseSuggestion[]> {
    const response = await this.client.chat.completions.create({
      model: 'gpt-4o',
      messages: [
        {
          role: 'system',
          content: `Create 3 unique paraphrases of the given text. Each should maintain the original meaning but use different vocabulary and sentence structure. Return JSON array with: originalText, paraphrasedText, uniquenessScore (0-1), improvement (percentage).`
        },
        {
          role: 'user',
          content: text
        }
      ],
      response_format: { type: 'json_object' }
    });

    const result = JSON.parse(response.choices[0].message.content || '{"suggestions": []}');
    return result.suggestions || [];
  }
}

// Free AI Provider (using local algorithms and patterns)
class LocalAIProvider implements AIProvider {
  name = 'Local AI';

  async available(): Promise<boolean> {
    return true; // Always available as it's local
  }

  async analyzeForPlagiarism(text: string): Promise<{
    aiGenerated: boolean;
    confidence: number;
    reasoning: string;
  }> {
    // Pattern-based AI detection
    const aiPatterns = [
      /\b(furthermore|moreover|additionally|consequently|therefore|thus|hence)\b/gi,
      /\b(it is important to note|it should be noted|it is worth mentioning)\b/gi,
      /\b(in conclusion|to summarize|in summary|overall)\b/gi,
      /\b(various|numerous|several|multiple)\b/gi,
      /\b(utilize|implement|facilitate|optimize)\b/gi
    ];

    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
    let aiScore = 0;
    let patternMatches = 0;

    // Check for AI-like patterns
    aiPatterns.forEach(pattern => {
      const matches = text.match(pattern);
      if (matches) {
        patternMatches += matches.length;
        aiScore += matches.length * 0.1;
      }
    });

    // Check sentence structure uniformity
    const avgSentenceLength = sentences.reduce((acc, s) => acc + s.length, 0) / sentences.length;
    const lengthVariation = sentences.reduce((acc, s) => acc + Math.abs(s.length - avgSentenceLength), 0) / sentences.length;
    
    if (lengthVariation < avgSentenceLength * 0.3) {
      aiScore += 0.2; // Low variation suggests AI
    }

    // Check for repetitive word usage
    const words = text.toLowerCase().match(/\b\w+\b/g) || [];
    const wordFreq = new Map<string, number>();
    words.forEach(word => wordFreq.set(word, (wordFreq.get(word) || 0) + 1));
    
    const uniqueWords = wordFreq.size;
    const totalWords = words.length;
    const diversity = uniqueWords / totalWords;
    
    if (diversity < 0.4) {
      aiScore += 0.15; // Low diversity suggests AI
    }

    const confidence = Math.min(0.9, aiScore); // Cap at 90% for local analysis
    const aiGenerated = confidence > 0.5;

    return {
      aiGenerated,
      confidence,
      reasoning: `Pattern analysis detected ${patternMatches} AI-like phrases, sentence variation: ${lengthVariation.toFixed(1)}, word diversity: ${(diversity * 100).toFixed(1)}%`
    };
  }

  async generateParaphrase(text: string): Promise<ParaphraseSuggestion[]> {
    // Simple rule-based paraphrasing
    const synonyms = new Map([
      ['important', 'crucial'],
      ['good', 'excellent'],
      ['bad', 'poor'],
      ['big', 'large'],
      ['small', 'tiny'],
      ['help', 'assist'],
      ['use', 'utilize'],
      ['show', 'demonstrate'],
      ['make', 'create'],
      ['get', 'obtain']
    ]);

    const suggestions: ParaphraseSuggestion[] = [];
    
    // Method 1: Synonym replacement
    let paraphrased1 = text;
    synonyms.forEach((synonym, word) => {
      const regex = new RegExp(`\\b${word}\\b`, 'gi');
      paraphrased1 = paraphrased1.replace(regex, synonym);
    });

    // Method 2: Sentence restructuring
    const sentences = text.split(/[.!?]+/).filter(s => s.trim());
    let paraphrased2 = sentences.map(sentence => {
      const words = sentence.trim().split(/\s+/);
      if (words.length > 3) {
        // Simple restructuring: move last word to beginning if it's not a conjunction
        const lastWord = words[words.length - 1];
        if (!['and', 'or', 'but', 'so'].includes(lastWord.toLowerCase())) {
          return `${lastWord} ${words.slice(0, -1).join(' ')}`;
        }
      }
      return sentence;
    }).join('. ') + '.';

    // Method 3: Passive to active voice conversion
    let paraphrased3 = text
      .replace(/\bwas\s+(\w+ed)\b/gi, 'actively $1')
      .replace(/\bis\s+(\w+ed)\b/gi, 'actively $1');

    suggestions.push(
      {
        originalText: text,
        paraphrasedText: paraphrased1,
        uniquenessScore: 0.7,
        improvement: 15
      },
      {
        originalText: text,
        paraphrasedText: paraphrased2,
        uniquenessScore: 0.6,
        improvement: 10
      },
      {
        originalText: text,
        paraphrasedText: paraphrased3,
        uniquenessScore: 0.5,
        improvement: 8
      }
    );

    return suggestions.filter(s => s.paraphrasedText !== text);
  }
}

// Hugging Face Provider (free alternative)
class HuggingFaceProvider implements AIProvider {
  name = 'Hugging Face';

  async available(): Promise<boolean> {
    try {
      const response = await fetch('https://huggingface.co/api/models');
      return response.ok;
    } catch {
      return false;
    }
  }

  async analyzeForPlagiarism(text: string): Promise<{
    aiGenerated: boolean;
    confidence: number;
    reasoning: string;
  }> {
    try {
      // Using a free AI detection model from Hugging Face
      const response = await fetch('https://api-inference.huggingface.co/models/roberta-base-openai-detector', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          inputs: text.slice(0, 512) // Limit to 512 characters for free tier
        })
      });

      if (!response.ok) {
        throw new Error('HuggingFace API error');
      }

      const result = await response.json();
      const aiScore = result[0]?.score || 0;
      
      return {
        aiGenerated: aiScore > 0.5,
        confidence: aiScore,
        reasoning: `Hugging Face AI detector analysis with ${(aiScore * 100).toFixed(1)}% confidence`
      };
    } catch (error) {
      // Fallback to local analysis
      const localProvider = new LocalAIProvider();
      return localProvider.analyzeForPlagiarism(text);
    }
  }

  async generateParaphrase(text: string): Promise<ParaphraseSuggestion[]> {
    // Use local provider for paraphrasing as HF paraphrasing models require API keys
    const localProvider = new LocalAIProvider();
    return localProvider.generateParaphrase(text);
  }
}

// AI Provider Manager with failsafe mechanism
export class AIProviderManager {
  private providers: AIProvider[] = [];
  private primaryProvider: AIProvider | null = null;

  constructor() {
    this.providers = [
      new OpenAIProvider(),
      new HuggingFaceProvider(),
      new LocalAIProvider() // Always available fallback
    ];
  }

  async initialize(): Promise<void> {
    // Test all providers and set primary
    for (const provider of this.providers) {
      if (await provider.available()) {
        this.primaryProvider = provider;
        console.log(`AI Provider initialized: ${provider.name}`);
        break;
      }
    }

    if (!this.primaryProvider) {
      // This should never happen since LocalAIProvider is always available
      this.primaryProvider = new LocalAIProvider();
    }
  }

  async analyzeForPlagiarism(text: string): Promise<{
    aiGenerated: boolean;
    confidence: number;
    reasoning: string;
    provider: string;
  }> {
    for (const provider of this.providers) {
      try {
        if (await provider.available()) {
          const result = await provider.analyzeForPlagiarism(text);
          return {
            ...result,
            provider: provider.name
          };
        }
      } catch (error) {
        console.error(`Provider ${provider.name} failed:`, error);
        continue;
      }
    }

    // This should never be reached due to LocalAIProvider fallback
    throw new Error('All AI providers failed');
  }

  async generateParaphrase(text: string): Promise<ParaphraseSuggestion[]> {
    for (const provider of this.providers) {
      try {
        if (await provider.available()) {
          return await provider.generateParaphrase(text);
        }
      } catch (error) {
        console.error(`Provider ${provider.name} failed:`, error);
        continue;
      }
    }

    // Fallback to empty array
    return [];
  }

  getAvailableProviders(): string[] {
    return this.providers.map(p => p.name);
  }

  getCurrentProvider(): string {
    return this.primaryProvider?.name || 'None';
  }
}

export const aiProviderManager = new AIProviderManager();